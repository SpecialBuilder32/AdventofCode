# Advent of Code 2024

# Start Time: 12:14 AM

# Pt 1 End Time: 12:24 AM
# Pt 2 End Time: 

# Total Time: 

import numpy as np
# Part 1 - psudorandom sequence generating
    # ..do I suspect that there is some clever math trick to make this fater than manually iterating?
    # probably. If there is I dont doubt it'll come in in part 2 though :P

seeds = []
with open("Day 22/Day22_Input.txt", "r") as f:
    for line in f.readlines():
        seeds.append(int(line))

def evolve(num: int) -> int:
    # evolves a number into its psudorandom successor
    num = mix(num, num*64)
    num = prune(num)

    num = mix(num, num//32)
    num = prune(num)

    num = mix(num, num*2048)
    num = prune(num)

    return num

def mix(into: int, num: int) -> int:
    return into^num

def prune(num: int) -> int:
    return num%16777216

# P2 - initialize storage of prices
prices = np.empty((len(seeds), 2000), dtype=int)

# find the 2000'th number generated by each starting seed
secret_sum = 0
for i, seed in enumerate(seeds):
    num = seed
    for j in range(2000):
        num = evolve(num)
        prices[i,j] = num%10 # ones digit of number
    secret_sum += num

print(f"sum of 2000th secret numbers is {secret_sum}")
#... this was suspiciously straightforward, even though it took 10 seconds to run


## Part 2 - Finding the best set of 4 deltas to buy the most bananas!
    # first we need to store all the prices calculated from the secret numbers - done inline with above
    # doesn't increase runtime significanly yet

# next calculate differences in price-over-time
diffs = np.diff(prices, axis=1)

from itertools import product
from alive_progress import alive_bar
# to get the absolute max sequence, we need to exhaustively check every possible sequence... lets hope that
    # takes not too long
best_seq = ()
best_haul = 0 # banannas
with alive_bar(73440) as bar:
    for seq in product(range(-9,9), repeat=4): # there are 73000 sequences to check. Ugh
        # is this sequence impossible? If so we can skip!
        if np.any(np.abs(np.cumsum(seq)) > 9):
            bar(skipped=True) # exclude this from ETA calculation
            continue

        # now check the prices for this sequence
        price = 0
        for i, seller_diffs in enumerate(diffs):
            for j in range(len(seller_diffs)-4):
                if np.all(seller_diffs[j:j+4] == seq):
                    # an instance of this sequence
                    price += prices[i, j+4]
                    break # we've bought from this seller, onto the next
        
        # is this the best sequence?
        if price > best_haul:
            best_haul = price
            best_seq = seq
            print(f"A new best sequence has been found: {seq} with a total of {price} bananas")
        
        # update progress bar - this is going to take a while I can't think of any way around it
        bar()

print(f"The best sequence for the monkey to act on is {best_seq}, yielding {best_haul} bananas")